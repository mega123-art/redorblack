<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red or Black - Neon Casino</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="config.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', monospace;
            background: radial-gradient(ellipse at center, #1a0000 0%, #000000 70%);
            color: #fff;
            overflow-x: hidden;
            position: relative;
            min-height: 100vh;
        }

        /* Animated neon grid background */
        .bg-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(255,0,0,0.2) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,0,0,0.2) 1px, transparent 1px);
            background-size: 40px 40px;
            animation: gridGlow 3s ease-in-out infinite alternate;
            z-index: -2;
        }

        @keyframes gridGlow {
            0% { opacity: 0.3; background-size: 40px 40px; }
            100% { opacity: 0.6; background-size: 42px 42px; }
        }

        /* Floating red particles */
        .bg-grid::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(2px 2px at 20% 30%, #ff0000, transparent),
                radial-gradient(2px 2px at 80% 70%, #ff0040, transparent),
                radial-gradient(1px 1px at 90% 40%, #ff0020, transparent),
                radial-gradient(1px 1px at 50% 60%, #ff0000, transparent);
            background-size: 200% 100%;
            animation: particles 8s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes particles {
            0%, 100% { transform: translateY(0); opacity: 0.8; }
            50% { transform: translateY(-10px); opacity: 1; }
        }

        /* Red neon glow utility */
        .neon-red {
            color: #ff0000;
            text-shadow: 
                0 0 5px #ff0000,
                0 0 10px #ff0000,
                0 0 15px #ff0000,
                0 0 20px #ff0000,
                0 0 30px #ff0000;
        }

        .neon-red-border {
            border: 2px solid #ff0000;
            box-shadow: 
                0 0 10px #ff0000,
                0 0 20px #ff0000,
                0 0 30px #ff0000,
                inset 0 0 10px rgba(255,0,0,0.1);
        }

        /* Header */
        .header {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #000000 0%, #330000 50%, #000000 100%);
            border-bottom: 3px solid #ff0000;
            box-shadow: 0 3px 20px #ff0000;
            position: relative;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,0,0,0.1), transparent);
            animation: headerScan 4s linear infinite;
        }

        @keyframes headerScan {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .logo {
            font-size: 5rem;
            font-weight: 900;
            color: #ff4444;
            text-shadow: 
                0 0 2px #ff0000,
                0 0 4px #ff0000;
            animation: logoFire 2s ease-in-out infinite alternate;
            margin-bottom: 15px;
            position: relative;
            z-index: 1;
        }

        @keyframes logoFire {
            from { 
                text-shadow: 
                    0 0 2px #ff0000,
                    0 0 4px #ff0000;
            }
            to { 
                text-shadow: 
                    0 0 3px #ff0000,
                    0 0 6px #ff0000;
            }
        }

        .subtitle {
            font-size: 1.4rem;
            color: #cc0000;
            letter-spacing: 4px;
            text-transform: uppercase;
            position: relative;
            z-index: 1;
        }

        /* Main container */
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 30px;
            display: grid;
            grid-template-columns: 1fr 450px;
            gap: 40px;
            min-height: calc(100vh - 200px);
        }

        /* Game area */
        .game-area {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        /* Timer section */
        .timer-section {
            background: linear-gradient(135deg, #000000, #1a0000, #000000);
            border: 3px solid #ff0000;
            border-radius: 25px;
            padding: 50px;
            text-align: center;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 0 30px #ff0000,
                inset 0 0 30px rgba(255,0,0,0.1);
        }

        .timer-section::before {
            content: '';
            position: absolute;
            top: -100%;
            left: -100%;
            width: 300%;
            height: 300%;
            background: conic-gradient(transparent, rgba(255,0,0,0.3), transparent, rgba(255,0,0,0.1));
            animation: timerRotate 4s linear infinite;
        }

        @keyframes timerRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .timer-display {
            font-size: 8rem;
            font-weight: 900;
            color: #ff4444;
            text-shadow: 
                0 0 3px #ff0000,
                0 0 6px #ff0000;
            position: relative;
            z-index: 1;
            animation: timerPulse 1s ease-in-out infinite;
        }

        @keyframes timerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .round-info {
            font-size: 2rem;
            margin-top: 20px;
            color: #ff0000;
            text-shadow: 0 0 15px #ff0000;
            position: relative;
            z-index: 1;
            font-weight: 700;
        }

        .status {
            font-size: 2.2rem;
            margin-top: 15px;
            font-weight: 900;
            position: relative;
            z-index: 1;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Voting section */
        .voting-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 20px 0;
        }

        .vote-button {
            padding: 80px 50px;
            border: 4px solid;
            border-radius: 25px;
            font-family: 'Orbitron', monospace;
            font-size: 3.5rem;
            font-weight: 900;
            cursor: pointer;
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 20px currentColor;
        }

        .vote-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.6s;
        }

        .vote-button:hover::before {
            left: 100%;
        }

        .red-button {
            background: linear-gradient(135deg, #ff0000, #cc0000, #ff0000);
            color: #fff;
            border-color: #ff0000;
            box-shadow: 
                0 0 30px #ff0000,
                0 0 60px #ff0000,
                inset 0 0 30px rgba(255,0,0,0.2);
        }

        .red-button:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 
                0 20px 60px #ff0000,
                0 0 80px #ff0000,
                inset 0 0 40px rgba(255,0,0,0.3);
        }

        .red-button:active {
            transform: translateY(-4px) scale(0.98);
        }

        .black-button {
            background: linear-gradient(135deg, #000000, #1a0000, #000000);
            color: #ff0000;
            border-color: #ff0000;
            box-shadow: 
                0 0 30px #ff0000,
                0 0 60px rgba(255,0,0,0.5),
                inset 0 0 30px rgba(255,0,0,0.1);
        }

        .black-button:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 
                0 20px 60px #ff0000,
                0 0 80px #ff0000,
                inset 0 0 40px rgba(255,0,0,0.2);
            color: #fff;
            background: linear-gradient(135deg, #1a0000, #330000, #1a0000);
        }

        .black-button:active {
            transform: translateY(-4px) scale(0.98);
        }

        .vote-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            filter: grayscale(50%);
        }

        /* Vote counts */
        .vote-counts {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 30px;
        }

        .vote-count {
            background: linear-gradient(135deg, #000000, #1a0000);
            border: 3px solid #ff0000;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            box-shadow: 
                0 0 25px #ff0000,
                inset 0 0 25px rgba(255,0,0,0.1);
            position: relative;
            overflow: hidden;
        }

        .vote-count::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,0,0,0.2), transparent);
            animation: countScan 3s ease-in-out infinite;
        }

        @keyframes countScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .count-number {
            font-size: 4rem;
            font-weight: 900;
            margin-bottom: 15px;
            color: #ff0000;
            text-shadow: 
                0 0 15px #ff0000,
                0 0 30px #ff0000;
            position: relative;
            z-index: 1;
        }

        .count-label {
            font-size: 1.4rem;
            color: #cc0000;
            font-weight: 700;
            letter-spacing: 1px;
            position: relative;
            z-index: 1;
        }




        /* Sidebar */
        .sidebar {
            background: linear-gradient(135deg, #000000, #1a0000, #000000);
            border: 3px solid #ff0000;
            border-radius: 25px;
            padding: 30px;
            height: fit-content;
            box-shadow: 
                0 0 30px #ff0000,
                inset 0 0 30px rgba(255,0,0,0.1);
            position: relative;
            overflow: hidden;
        }

        .sidebar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, transparent, #ff0000, transparent);
            animation: sidebarScan 2s ease-in-out infinite;
        }

        @keyframes sidebarScan {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .sidebar-section {
            margin-bottom: 40px;
            position: relative;
            z-index: 1;
        }

        .sidebar-title {
            font-size: 1.8rem;
            font-weight: 900;
            margin-bottom: 20px;
            color: #ff0000;
            text-align: center;
            padding-bottom: 15px;
            border-bottom: 2px solid #ff0000;
            text-shadow: 0 0 15px #ff0000;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Wallet section */
        .wallet-section input {
            width: 100%;
            padding: 20px;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #000000, #1a0000);
            border: 2px solid #ff0000;
            border-radius: 15px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-size: 16px;
            box-shadow: 
                0 0 15px rgba(255,0,0,0.3),
                inset 0 0 15px rgba(255,0,0,0.1);
        }

        .wallet-section input::placeholder {
            color: #cc0000;
        }

        .wallet-section input:focus {
            outline: none;
            box-shadow: 
                0 0 25px #ff0000,
                inset 0 0 25px rgba(255,0,0,0.2);
        }

        .verify-btn {
            width: 100%;
            padding: 20px;
            background: linear-gradient(135deg, #ff0000, #cc0000, #ff0000);
            border: 3px solid #ff0000;
            border-radius: 15px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 
                0 0 20px #ff0000,
                inset 0 0 20px rgba(255,0,0,0.2);
        }

        .verify-btn:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 10px 30px #ff0000,
                inset 0 0 30px rgba(255,0,0,0.3);
        }

        /* Voters list */
        .voters-list {
            max-height: 350px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .voter-item {
            background: linear-gradient(135deg, #000000, #1a0000);
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 12px;
            border: 2px solid #ff0000;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 
                0 0 10px rgba(255,0,0,0.3),
                inset 0 0 10px rgba(255,0,0,0.1);
            transition: all 0.3s ease;
            min-height: 50px;
            gap: 10px;
        }

        .voter-item:hover {
            transform: translateX(5px);
            box-shadow: 
                0 0 20px rgba(255,0,0,0.5),
                inset 0 0 20px rgba(255,0,0,0.2);
        }

        .voter-address {
            font-family: monospace;
            color: #fff;
            text-shadow: 0 0 5px #ff0000;
            flex: 1;
            min-width: 0;
            word-break: break-all;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: calc(100% - 80px);
        }

        .voter-vote {
            font-weight: 900;
            font-size: 12px;
            padding: 8px 12px;
            border-radius: 8px;
            text-transform: uppercase;
            border: 1px solid #ff0000;
            flex-shrink: 0;
            min-width: 60px;
            text-align: center;
        }

        .voter-vote.red {
            background: #ff0000;
            color: #fff;
            box-shadow: 0 0 10px #ff0000;
        }

        .voter-vote.black {
            background: #000000;
            color: #ff0000;
            box-shadow: 0 0 10px #ff0000;
        }

        /* Stats section */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .expanded-winner {
            grid-column: 1 / -1;
            min-height: 80px;
            padding: 25px;
            background: linear-gradient(135deg, #1a0000, #330000, #1a0000);
            border: 3px solid #ff0000;
            box-shadow: 
                0 0 30px #ff0000,
                0 0 60px rgba(255,0,0,0.3),
                inset 0 0 30px rgba(255,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        
        .expanded-winner::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,0,0,0.2), transparent);
            animation: winnerScan 3s ease-in-out infinite;
        }
        
        @keyframes winnerScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        .expanded-winner .stat-value {
            font-size: 2.5rem;
            font-weight: 900;
            color: #ff0000;
            text-shadow: 
                0 0 20px #ff0000,
                0 0 40px #ff0000;
            margin-bottom: 10px;
            position: relative;
            z-index: 1;
        }
        
        .expanded-winner .stat-label {
            font-size: 1.2rem;
            color: #cc0000;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            z-index: 1;
        }
        
        .winner-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            position: relative;
            z-index: 1;
        }
        
        .winner-info {
            flex: 1;
        }
        
        .copy-winner-btn {
            background: linear-gradient(135deg, #ff0000, #cc0000);
            border: 2px solid #ff0000;
            border-radius: 12px;
            padding: 12px 16px;
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 
                0 0 15px rgba(255,0,0,0.3),
                inset 0 0 15px rgba(255,0,0,0.1);
            position: relative;
            overflow: hidden;
            min-width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .copy-winner-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 
                0 8px 25px rgba(255,0,0,0.5),
                0 0 30px rgba(255,0,0,0.4),
                inset 0 0 20px rgba(255,0,0,0.2);
            background: linear-gradient(135deg, #ff3333, #ff0000);
        }
        
        .copy-winner-btn:active {
            transform: translateY(0) scale(0.95);
        }
        
        .copy-winner-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.6s;
        }
        
        .copy-winner-btn:hover::before {
            left: 100%;
        }
        
        .copy-winner-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .stat-item {
            background: linear-gradient(135deg, #000000, #1a0000);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid #ff0000;
            box-shadow: 
                0 0 15px rgba(255,0,0,0.3),
                inset 0 0 15px rgba(255,0,0,0.1);
            transition: all 0.3s ease;
        }

        .stat-item:hover {
            transform: scale(1.05);
            box-shadow: 
                0 0 25px rgba(255,0,0,0.5),
                inset 0 0 25px rgba(255,0,0,0.2);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 900;
            color: #ff0000;
            display: block;
            text-shadow: 0 0 15px #ff0000;
            margin-bottom: 8px;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #cc0000;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Pool announcement */
        .pool-announcement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #000000, #330000, #000000);
            border: 5px solid #ff0000;
            border-radius: 30px;
            padding: 60px;
            text-align: center;
            z-index: 1001;
            display: none;
            box-shadow: 
                0 0 100px #ff0000,
                0 0 200px rgba(255,0,0,0.5),
                inset 0 0 50px rgba(255,0,0,0.2);
            animation: poolAnnouncementGlow 2s ease-in-out infinite alternate;
        }

        @keyframes poolAnnouncementGlow {
            from { 
                box-shadow: 0 0 100px #ff0000, 0 0 200px rgba(255,0,0,0.5), inset 0 0 50px rgba(255,0,0,0.2);
                transform: translate(-50%, -50%) scale(1);
            }
            to { 
                box-shadow: 0 0 120px #ff0000, 0 0 240px rgba(255,0,0,0.7), inset 0 0 60px rgba(255,0,0,0.3);
                transform: translate(-50%, -50%) scale(1.02);
            }
        }

        .pool-announcement.red {
            border-color: #ff0000;
            box-shadow: 
                0 0 100px #ff0000,
                0 0 200px rgba(255,0,0,0.5),
                inset 0 0 50px rgba(255,0,0,0.2);
        }

        .pool-announcement.black {
            border-color: #ff0000;
            box-shadow: 
                0 0 100px #ff0000,
                0 0 200px rgba(0,0,0,0.5),
                inset 0 0 50px rgba(0,0,0,0.2);
        }

        .pool-text {
            font-size: 4rem;
            font-weight: 900;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 
                0 0 20px currentColor,
                0 0 40px currentColor;
        }

        .pool-text.red {
            color: #ff0000;
        }

        .pool-text.black {
            color: #ffffff;
            text-shadow: 
                0 0 20px #ffffff,
                0 0 40px #ffffff,
                0 0 60px #ff0000;
        }

        .pool-subtitle {
            font-size: 1.8rem;
            color: #cc0000;
            text-shadow: 0 0 15px #ff0000;
            margin-bottom: 20px;
        }

        .pool-count {
            font-size: 1.4rem;
            color: #fff;
            text-shadow: 0 0 10px #ff0000;
            margin-bottom: 30px;
        }

        .continue-btn {
            background: linear-gradient(135deg, #ff0000, #cc0000);
            border: 3px solid #ff0000;
            padding: 20px 40px;
            border-radius: 15px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            font-size: 18px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 
                0 0 20px #ff0000,
                inset 0 0 20px rgba(255,0,0,0.2);
            transition: all 0.3s ease;
        }

        .continue-btn:hover {
            transform: scale(1.05);
            box-shadow: 
                0 0 30px #ff0000,
                inset 0 0 30px rgba(255,0,0,0.3);
        }

        /* Winner announcement */
        .winner-announcement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #000000, #330000, #000000);
            border: 5px solid #ff0000;
            border-radius: 30px;
            padding: 60px;
            text-align: center;
            z-index: 1000;
            display: none;
            box-shadow: 
                0 0 100px #ff0000,
                0 0 200px rgba(255,0,0,0.5),
                inset 0 0 50px rgba(255,0,0,0.2);
            animation: winnerGlow 1s ease-in-out infinite alternate;
        }

        @keyframes winnerGlow {
            from { box-shadow: 0 0 100px #ff0000, 0 0 200px rgba(255,0,0,0.5), inset 0 0 50px rgba(255,0,0,0.2); }
            to { box-shadow: 0 0 120px #ff0000, 0 0 240px rgba(255,0,0,0.7), inset 0 0 60px rgba(255,0,0,0.3); }
        }

        .winner-text {
            font-size: 3.5rem;
            font-weight: 900;
            margin-bottom: 30px;
            color: #ff0000;
            text-shadow: 
                0 0 20px #ff0000,
                0 0 40px #ff0000;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .winner-address {
            font-family: monospace;
            font-size: 1.2rem;
            color: #fff;
            text-shadow: 0 0 15px #ff0000;
            margin-bottom: 30px;
            word-break: break-all;
            background: rgba(255,0,0,0.1);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #ff0000;
        }

        .close-winner {
            background: linear-gradient(135deg, #ff0000, #cc0000);
            border: 3px solid #ff0000;
            padding: 20px 40px;
            border-radius: 15px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            font-size: 18px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 
                0 0 20px #ff0000,
                inset 0 0 20px rgba(255,0,0,0.2);
            transition: all 0.3s ease;
        }

        .close-winner:hover {
            transform: scale(1.05);
            box-shadow: 
                0 0 30px #ff0000,
                inset 0 0 30px rgba(255,0,0,0.3);
        }

        /* Connection status */
        .connection-status {
            position: fixed;
            top: 30px;
            right: 30px;
            padding: 15px 25px;
            border-radius: 30px;
            font-size: 14px;
            font-weight: 900;
            z-index: 100;
            border: 2px solid;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .connected {
            background: linear-gradient(135deg, #000000, #1a0000);
            color: #ff0000;
            border-color: #ff0000;
            box-shadow: 0 0 20px #ff0000;
        }

        .disconnected {
            background: linear-gradient(135deg, #330000, #660000);
            color: #fff;
            border-color: #ff0000;
            box-shadow: 0 0 20px #ff0000;
            animation: disconnectedBlink 1s ease-in-out infinite;
        }

        @keyframes disconnectedBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #000000;
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #ff0000, #cc0000);
            border-radius: 6px;
            border: 2px solid #000000;
            box-shadow: 0 0 10px #ff0000;
        }

        ::-webkit-scrollbar-thumb:hover {
            box-shadow: 0 0 20px #ff0000;
        }

        /* Pulse animation */
        .pulse {
            animation: pulseRed 1.5s ease-in-out infinite;
        }

        @keyframes pulseRed {
            0%, 100% { 
                text-shadow: 
                    0 0 10px #ff0000,
                    0 0 20px #ff0000,
                    0 0 30px #ff0000;
            }
            50% { 
                text-shadow: 
                    0 0 20px #ff0000,
                    0 0 30px #ff0000,
                    0 0 40px #ff0000,
                    0 0 50px #ff0000;
            }
        }

        /* Responsive */
        @media (max-width: 1400px) {
            .container {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                order: -1;
            }
        }

        @media (max-width: 768px) {
            .logo {
                font-size: 3rem;
            }
            
            .timer-display {
                font-size: 5rem;
            }
            
            .vote-button {
                padding: 50px 30px;
                font-size: 2.5rem;
            }
            
            .voting-section {
                grid-template-columns: 1fr;
            }

            .container {
                padding: 20px;
                gap: 20px;
            }
        }

        /* Loading animation */
        .loading {
            animation: loadingGlow 2s ease-in-out infinite;
        }

        @keyframes loadingGlow {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Spinner Styles */
        .spinner-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(15px);
        }

        .spinner-wheel {
            width: 400px;
            height: 400px;
            border-radius: 50%;
            position: relative;
            border: 8px solid #ff0000;
            box-shadow: 
                0 0 50px #ff0000,
                0 0 100px rgba(255,0,0,0.5),
                inset 0 0 50px rgba(255,0,0,0.2);
            transition: all 0.5s ease;
        }

        .spinner-wheel.spinning {
            animation: spin 3s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        .spinner-wheel.grey-phase {
            background: conic-gradient(
                #666666 0deg,
                #888888 180deg,
                #666666 360deg
            );
            border-color: #666666;
            box-shadow: 
                0 0 50px #666666,
                0 0 100px rgba(102,102,102,0.5),
                inset 0 0 50px rgba(102,102,102,0.2);
        }

        .spinner-wheel.red-black-phase {
            background: conic-gradient(
                #ff0000 0deg,
                #ff0000 180deg,
                #000000 180deg,
                #000000 360deg
            );
        }

        .spinner-pointer {
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-top: 30px solid #ff0000;
            z-index: 2;
            filter: drop-shadow(0 0 10px #ff0000);
        }

        .spinner-pointer.grey {
            border-top-color: #666666;
            filter: drop-shadow(0 0 10px #666666);
        }

        .spinner-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            font-weight: 900;
            color: #fff;
            text-shadow: 
                0 0 10px #ff0000,
                0 0 20px #ff0000;
            z-index: 3;
            text-align: center;
            width: 200px;
        }

        .spinner-text.grey {
            color: #ccc;
            text-shadow: 
                0 0 10px #666666,
                0 0 20px #666666;
        }

        .spinner-winner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: 900;
            color: #ff0000;
            text-shadow: 
                0 0 20px #ff0000,
                0 0 40px #ff0000;
            z-index: 3;
            text-align: center;
            animation: winnerPulse 1s ease-in-out infinite alternate;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(1800deg); }
        }

        @keyframes winnerPulse {
            0% { 
                transform: translate(-50%, -50%) scale(1);
                text-shadow: 
                    0 0 20px #ff0000,
                    0 0 40px #ff0000;
            }
            100% { 
                transform: translate(-50%, -50%) scale(1.1);
                text-shadow: 
                    0 0 30px #ff0000,
                    0 0 60px #ff0000;
            }
        }

        .spinner-phase-indicator {
            position: absolute;
            bottom: -60px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.2rem;
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .logo-image {
            width: 50px;
            cursor: pointer;
            height: 50px;
            position: absolute;
            top: 10;
            right: 260px;
        }
        .logo-image1 {
            width: 100px;
            cursor: pointer;
            height: 100px;
            position: relative;
            top: 10;
         left: 30px;
        }
    </style>
</head>
<body>
    <div class="bg-grid"></div>
    
    <div class="connection-status" id="connectionStatus">CONNECTING...</div>

    <header class="header">
        <a href="https://x.com/redorblackonsol" target="_blank"><img src="assets/logo.png" alt="Red or Black Logo" class="logo-image"></a>
        <img src="assets/image-215.png" alt="Red or Black Logo" class="logo-image1">
        <h1 class="logo">RED OR BLACK</h1>
        <p class="subtitle">CA: 5VNNqAmXtStTXKhe63cq6Y7BbHkk6Pjhy26N5qSCpump </p>
    </header>

    <div class="container">
        <div class="game-area">
            <!-- Timer Section -->
            <div class="timer-section">
                <div class="timer-display" id="timer">00:00</div>
                <div class="round-info">
                    Round <span id="currentRound">1</span>
                </div>
                <div class="status neon-red" id="gameStatus">LOADING...</div>
            </div>

            <!-- Voting Section -->
            <div class="voting-section" id="votingSection">
                <button class="vote-button red-button" id="redButton" onclick="vote('red')" disabled>
                    RED
                </button>
                <button class="vote-button black-button" id="blackButton" onclick="vote('black')" disabled>
                    BLACK
                </button>
            </div>

            <!-- Vote Counts -->
            <div class="vote-counts">
                <div class="vote-count">
                    <div class="count-number" id="redCount">0</div>
                    <div class="count-label">RED VOTES</div>
                </div>
                <div class="vote-count">
                    <div class="count-number" id="blackCount">0</div>
                    <div class="count-label">BLACK VOTES</div>
                </div>
            </div>

        </div>

        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Wallet Verification -->
            <div class="sidebar-section">
                <h3 class="sidebar-title">Wallet Verification</h3>
                <div class="wallet-section">
                    <input type="text" id="walletInput" placeholder="Enter Solana wallet address..." />
                    <button class="verify-btn" onclick="verifyWallet()">VERIFY WALLET</button>
                    <div id="verificationStatus" style="margin-top: 15px; font-size: 14px;"></div>
                </div>
            </div>

            <!-- Live Voters -->
            <div class="sidebar-section">
                <h3 class="sidebar-title">Live Voters</h3>
                <div class="voters-list" id="votersList">
                    <div style="text-align: center; color: #cc0000; padding: 30px; border: 1px dashed #ff0000; border-radius: 10px;">
                        No voters yet...
                    </div>
                </div>
            </div>

            <!-- Game Stats -->
            <div class="sidebar-section">
                <h3 class="sidebar-title">Game Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <span class="stat-value" id="totalPlayers">0</span>
                        <span class="stat-label">Total Players</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="totalRounds">0</span>
                        <span class="stat-label">Rounds Played</span>
                    </div>
                    <div class="stat-item expanded-winner">
                        <div class="winner-content">
                            <div class="winner-info">
                                <span class="stat-value" id="lastWinner">None</span>
                                <span class="stat-label">Latest Winner</span>
                            </div>
                            <button class="copy-winner-btn" id="copyWinnerBtn" onclick="copyWinnerAddress()" title="Copy winner address">
                                üìã
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Pool Announcement Modal -->
    <div class="pool-announcement" id="poolModal">
        <div class="pool-text" id="poolText">RED WINS!</div>
        <div class="pool-subtitle">Winning Pool</div>
        <div class="pool-count" id="poolCount">0 voters eligible</div>
        <button class="continue-btn" onclick="closePoolModal()">SPIN WHEEL</button>
    </div>

    <!-- Winner Announcement Modal -->
    <div class="winner-announcement" id="winnerModal">
        <div class="winner-text">üéâ WINNER! üéâ</div>
        <div class="winner-address" id="winnerAddress"></div>
        <div style="margin: 25px 0; font-size: 1.5rem; color: #ff0000; text-shadow: 0 0 15px #ff0000;">
            Prize: <span id="prizeAmount">0 SOL</span>
        </div>
        <button class="close-winner" onclick="closeWinnerModal()">CONTINUE</button>
    </div>

    <!-- Spinner Modal -->
    <div class="spinner-container" id="spinnerContainer">
        <div class="spinner-wheel red-black-phase" id="spinnerWheel">
            <div class="spinner-pointer" id="spinnerPointer"></div>
            <div class="spinner-text" id="spinnerText">CHOOSING COLOR...</div>
            <div class="spinner-phase-indicator" id="spinnerPhaseIndicator">Phase 1: Color Selection</div>
        </div>
    </div>

    <script>
          window.APP_CONFIG = {
    API_URL: "https://redorblack.onrender.com",
    WS_URL: "wss://redorblack.onrender.com",
  };
        // Global variables
        let socket = null;
        let isVerified = false;
        let hasVoted = false;
        let currentRoundNumber = 1;
        let gameState = null;
        let clientTimeLeft = 0;
        let timerInterval = null;
        let isSpinning = false;
        let poolAnnounced = false;
        let isInitialized = false;
        let lastVisibilityChange = 0;
        let isVerifying = false;
        let verificationCooldown = 0; // Prevent spinner for 5 seconds after verification

        // Initialize connection
        function initializeConnection() {
            // Use configuration
            socket = io(window.APP_CONFIG.WS_URL);
            
            socket.on('connect', () => {
                console.log('üî¥ Connected to Red or Black Casino');
                updateConnectionStatus(true);
                createConnectionParticles();
            });

            socket.on('disconnect', () => {
                console.log('‚ö´ Disconnected from server');
                updateConnectionStatus(false);
            });

            socket.on('gameUpdate', (data) => {
                console.log('üé∞ Game update received:', data);
                
                // Always update game state, but block spinner during verification/cooldown
                updateGameUI(data);
                
                // Only block particles during verification
                if (!isVerifying) {
                    createUpdateParticles();
                }
            });

            // Initial data request
            fetchGameStatus();
            fetchParticipants();
        }

        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            if (connected) {
                status.textContent = 'üî¥ CONNECTED';
                status.className = 'connection-status connected';
            } else {
                status.textContent = '‚ö´ DISCONNECTED';
                status.className = 'connection-status disconnected';
            }
        }

        // Fetch game status from API
        async function fetchGameStatus() {
            try {
                const response = await fetch(`${window.APP_CONFIG.API_URL}/api/status`);
                const data = await response.json();
                if (data.success) {
                    // Only update if user is not verifying
                    if (!isVerifying && Date.now() >= verificationCooldown) {
                        updateGameUI(data);
                    }
                }
            } catch (error) {
                console.error('‚ùå Error fetching game status:', error);
            }
        }

        // Fetch participants
        async function fetchParticipants() {
            try {
                const response = await fetch(`${window.APP_CONFIG.API_URL}/api/participants`);
                const data = await response.json();
                if (data.success) {
                    updateVotersList(data.recentVotes);
                }
            } catch (error) {
                console.error('‚ùå Error fetching participants:', error);
            }
        }

        // Update the entire UI with game data
        function updateGameUI(data) {
            gameState = data;
            
            if (data.gameState) {
                // Update round info
                currentRoundNumber = data.gameState.currentRound;
                document.getElementById('currentRound').textContent = currentRoundNumber;
                
                // Update timer - always sync with server
                const serverTimeLeft = data.gameState.timeLeft || 0;
                const fallbackTime = data.config?.roundDuration ? Math.floor(data.config.roundDuration / 1000) : 30;
                
                // Use server time if reasonable, otherwise use fallback
                const timeToUse = serverTimeLeft > 0 ? serverTimeLeft : fallbackTime;
                
                // Always update timer to stay in sync with server
                updateTimer(timeToUse);
                
                // Update stats
                document.getElementById('totalRounds').textContent = data.gameState.totalRoundsPlayed;
                
                if (data.gameState.lastWinner) {
                    const winnerAddress = data.gameState.lastWinner;
                    const shortAddress = winnerAddress.length > 16 ? 
                        `${winnerAddress.substring(0, 8)}...${winnerAddress.substring(winnerAddress.length - 6)}` : 
                        winnerAddress;
                    document.getElementById('lastWinner').textContent = shortAddress;
                    document.getElementById('lastWinner').title = `Full address: ${winnerAddress}`;
                    
                    // Enable copy button and store full address
                    const copyBtn = document.getElementById('copyWinnerBtn');
                    copyBtn.disabled = false;
                    copyBtn.setAttribute('data-address', winnerAddress);
                    copyBtn.title = 'Copy winner address to clipboard';
                } else {
                    document.getElementById('lastWinner').textContent = 'No Winner Yet';
                    document.getElementById('lastWinner').title = 'No winner in the latest round';
                    
                    // Disable copy button
                    const copyBtn = document.getElementById('copyWinnerBtn');
                    copyBtn.disabled = true;
                    copyBtn.removeAttribute('data-address');
                    copyBtn.title = 'No winner to copy';
                }
            }

            if (data.roundData) {
                // Update vote counts with animation
                animateCountUpdate('redCount', data.roundData.votes.red || 0);
                animateCountUpdate('blackCount', data.roundData.votes.black || 0);
                document.getElementById('totalPlayers').textContent = data.roundData.participants || 0;
                
                // Debug winner information
                if (data.roundData.winner) {
                    console.log('üèÜ Winner received from server:', data.roundData.winner);
                }
                if (data.roundData.winningColor) {
                    console.log('üé® Winning color:', data.roundData.winningColor);
                }
                if (data.roundData.recentVotes) {
                    console.log('üó≥Ô∏è Recent votes count:', data.roundData.recentVotes.length);
                }
                
                // Update game status and UI based on round status
                updateGameStatus(data.roundData.status, data.roundData);
            }

            // Fetch updated participants
            fetchParticipants();
        }

        // Animate count updates
        function animateCountUpdate(elementId, newValue) {
            const element = document.getElementById(elementId);
            const currentValue = parseInt(element.textContent) || 0;
            
            if (currentValue !== newValue) {
                element.style.transform = 'scale(1.2)';
                element.style.transition = 'transform 0.3s ease';
                
                setTimeout(() => {
                    element.textContent = newValue;
                    element.style.transform = 'scale(1)';
                    createVoteParticles(element);
                }, 150);
            }
        }

        // Update game status
        function updateGameStatus(status, roundData) {
            console.log('üéÆ Updating game status:', status);
            console.log('üìä Round data:', roundData);
            console.log('üîß Is initialized:', isInitialized);
            
            const statusElement = document.getElementById('gameStatus');
            const votingSection = document.getElementById('votingSection');
            
            // During initialization, only show basic status updates
            if (!isInitialized) {
                console.log('‚ö†Ô∏è App not initialized, showing basic status only');
                statusElement.innerHTML = '‚è≥ LOADING...';
                statusElement.className = 'status neon-red loading';
                // Keep voting section visible but disabled during loading
                votingSection.style.display = 'grid';
                disableVoting();
                return;
            }
            
            switch (status) {
                case 'voting':
                    console.log('üó≥Ô∏è VOTING ACTIVE - Resetting all states');
                    isSpinning = false;
                    poolAnnounced = false;
                    hasVoted = false; // Reset voting state for new round
                    
                    statusElement.innerHTML = 'üó≥Ô∏è VOTING ACTIVE';
                    statusElement.className = 'status neon-red pulse';
                    votingSection.style.display = 'grid';
                    enableVoting();
                    break;
                    
                case 'spinning':
                    console.log('üé∞ SPINNING STATUS - Showing pool announcement');
                    
                    // Set spinning state
                    isSpinning = true;
                    poolAnnounced = false;
                    
                    statusElement.innerHTML = 'üé∞ SELECTING WINNER...';
                    statusElement.className = 'status neon-red pulse';
                    votingSection.style.display = 'grid';
                    disableVoting();
                    
                    // Show pool announcement directly
                    const winningColor = gameState?.roundData?.winningColor;
                    const eligibleVotes = gameState?.roundData?.recentVotes?.filter(vote => vote.color === winningColor) || [];
                    
                    console.log('üé® Winning color:', winningColor);
                    console.log('üë• Eligible votes:', eligibleVotes.length);
                    
                    if (winningColor) {
                        console.log('üèÜ Showing pool announcement for winning color:', winningColor);
                        showPoolAnnouncement(winningColor, eligibleVotes.length);
                    } else {
                        console.log('‚ö†Ô∏è No winning color yet, waiting for server data');
                        // Wait for server to provide winning color
                    }
                    break;
                    
                case 'completed':
                    console.log('‚úÖ ROUND COMPLETED - Resetting spinning state');
                    isSpinning = false;
                    poolAnnounced = false;
                    
                    statusElement.innerHTML = '‚úÖ ROUND COMPLETE';
                    statusElement.className = 'status neon-red';
                    // Keep voting section visible but disable voting
                    votingSection.style.display = 'grid';
                    disableVoting();
                    
                    if (roundData.winner) {
                        setTimeout(() => {
                            showWinner(roundData.winner, roundData.prizeAmount, roundData.winningColor);
                        }, 1000);
                    }
                    break;
                    
                default:
                    statusElement.innerHTML = '‚è≥ PREPARING ROUND...';
                    statusElement.className = 'status neon-red loading';
                    // Keep voting section visible but disabled
                    votingSection.style.display = 'grid';
                    disableVoting();
            }
        }

        // Synchronized timer update
        function updateTimer(timeLeft) {
            console.log('üïê Timer update from server:', timeLeft, 'seconds');
            
            // Clear existing timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Set new time from server (authoritative)
            clientTimeLeft = Math.max(0, timeLeft);
            
            // Start countdown if time > 0
            if (clientTimeLeft > 0) {
                timerInterval = setInterval(() => {
                    clientTimeLeft = Math.max(0, clientTimeLeft - 1);
                    displayTimer(clientTimeLeft);
                    
                    // Sync with server every 5 seconds
                    if (clientTimeLeft % 5 === 0) {
                        fetchGameStatus();
                    }
                }, 1000);
            }
            
            // Display current time
            displayTimer(clientTimeLeft);
        }
        
        // Display timer with effects
        function displayTimer(timeLeft) {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            const display = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            const timerElement = document.getElementById('timer');
            
            timerElement.textContent = display;
            
            if (timeLeft <= 10 && timeLeft > 0) {
                timerElement.classList.add('pulse');
                timerElement.style.color = '#ff4444';
                
                // Create urgency particles
                if (timeLeft <= 5) {
                    createUrgencyParticles();
                }
            } else {
                timerElement.classList.remove('pulse');
                timerElement.style.color = '#ff4444';
            }
        }

        // Wallet verification with enhanced feedback
        async function verifyWallet() {
            const walletAddress = document.getElementById('walletInput').value.trim();
            const statusDiv = document.getElementById('verificationStatus');
            const verifyBtn = document.querySelector('.verify-btn');
            
            if (!walletAddress) {
                statusDiv.innerHTML = '<span style="color: #ff0000; text-shadow: 0 0 10px #ff0000;">‚ö†Ô∏è Please enter wallet address</span>';
                return;
            }
            
            // Set verification flag to prevent spinner from appearing
            isVerifying = true;
            verificationCooldown = Date.now() + 15000; // Set 15 second protection immediately
            console.log('üîí Starting verification - blocking spinner for 15 seconds');
            
            verifyBtn.textContent = 'VERIFYING...';
            verifyBtn.style.opacity = '0.7';
            statusDiv.innerHTML = '<span style="color: #ff0000; text-shadow: 0 0 10px #ff0000;">üîç Checking token balance...</span>';
            
            try {
                const response = await fetch(`${window.APP_CONFIG.API_URL}/api/verify-wallet`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ walletAddress })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    isVerified = true;
                    statusDiv.innerHTML = `<span style="color: #ff0000; text-shadow: 0 0 15px #ff0000;">‚úÖ VERIFIED! Balance: ${Math.floor(data.balance / 1000000)}M tokens</span>`;
                    verifyBtn.textContent = 'WALLET VERIFIED';
                    verifyBtn.style.background = 'linear-gradient(135deg, #ff0000, #cc0000)';
                    createVerificationParticles();
                    
                    // Allow game updates but block spinner for 15 seconds after verification
                    verificationCooldown = Date.now() + 15000;
                    console.log('üîí Verification cooldown extended to 15 seconds');
                    
                    // Enable voting directly after verification
                    setTimeout(() => {
                        enableVoting();
                    }, 1000);
                } else {
                    isVerified = false;
                    statusDiv.innerHTML = `<span style="color: #ff0000; text-shadow: 0 0 15px #ff0000;">‚ùå ${data.error}</span>`;
                    verifyBtn.textContent = 'VERIFICATION FAILED';
                }
                
                // Keep verification flag true for a bit longer to ensure no spinner appears
                setTimeout(() => {
                    isVerifying = false;
                    console.log('üîì Verification flag cleared');
                }, 5000);
            } catch (error) {
                statusDiv.innerHTML = '<span style="color: #ff0000; text-shadow: 0 0 15px #ff0000;">‚ùå Network error - Try again</span>';
                console.error('Verification error:', error);
                // Clear verification flag on error too
                setTimeout(() => {
                    isVerifying = false;
                    verificationCooldown = 0;
                    console.log('üîì Verification flag cleared after error');
                }, 5000);
            }
            
            verifyBtn.style.opacity = '1';
            setTimeout(() => {
                if (verifyBtn.textContent !== 'WALLET VERIFIED') {
                    verifyBtn.textContent = 'VERIFY WALLET';
                }
            }, 3000);
        }

        // Enhanced voting with explosive effects
        async function vote(color) {
            if (!isVerified) {
                alert('üö´ Please verify your wallet first!');
                return;
            }
            
            const walletAddress = document.getElementById('walletInput').value.trim();
            const button = color === 'red' ? document.getElementById('redButton') : document.getElementById('blackButton');
            
            // Pre-vote animation
            button.style.transform = 'scale(0.95)';
            createVoteExplosion(button, color);
            
            try {
                const response = await fetch(`${window.APP_CONFIG.API_URL}/api/vote`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ walletAddress, color })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    hasVoted = true;
                    disableVoting();
                    
                    // Success animation
                    button.style.transform = 'scale(1.1)';
                    button.style.boxShadow = `0 0 80px #ff0000, 0 0 120px #ff0000`;
                    
                    setTimeout(() => {
                        button.style.transform = 'scale(1)';
                        button.style.boxShadow = '';
                    }, 500);
                    
                    // Play success sound
                    playSound('vote');
                    
                    console.log('üéØ Vote cast successfully:', data);
                } else {
                    alert(`‚ùå Vote failed: ${data.error}`);
                    button.style.transform = 'scale(1)';
                }
            } catch (error) {
                alert('‚ùå Network error. Please try again.');
                console.error('Vote error:', error);
                button.style.transform = 'scale(1)';
            }
        }

        // Enable/disable voting buttons
        function enableVoting() {
            const redBtn = document.getElementById('redButton');
            const blackBtn = document.getElementById('blackButton');
            
            console.log('üîß enableVoting called - isVerified:', isVerified, 'hasVoted:', hasVoted, 'gameStatus:', gameState?.roundData?.status);
            
            // Simple: Enable if verified and not voted yet
            if (isVerified && !hasVoted) {
                redBtn.disabled = false;
                blackBtn.disabled = false;
                
                // Add pulsing effect when enabled
                redBtn.style.animation = 'pulseRed 2s ease-in-out infinite';
                blackBtn.style.animation = 'pulseRed 2s ease-in-out infinite';
                
                console.log('‚úÖ Voting buttons ENABLED');
            } else {
                // Disable but keep visible
                redBtn.disabled = true;
                blackBtn.disabled = true;
                redBtn.style.animation = 'none';
                blackBtn.style.animation = 'none';
                
                console.log('‚ùå Voting buttons DISABLED - isVerified:', isVerified, 'hasVoted:', hasVoted);
            }
        }

        function disableVoting() {
            const redBtn = document.getElementById('redButton');
            const blackBtn = document.getElementById('blackButton');
            
            redBtn.disabled = true;
            blackBtn.disabled = true;
            redBtn.style.animation = 'none';
            blackBtn.style.animation = 'none';
        }

        // Update voters list with enhanced styling
        function updateVotersList(votes) {
            const votersList = document.getElementById('votersList');
            
            if (!votes || votes.length === 0) {
                votersList.innerHTML = `
                    <div style="text-align: center; color: #cc0000; padding: 30px; border: 1px dashed #ff0000; border-radius: 10px; background: rgba(255,0,0,0.05);">
                        <div style="font-size: 1.5rem; margin-bottom: 10px;">‚è≥</div>
                        Waiting for first voter...
                    </div>
                `;
                return;
            }
            
            votersList.innerHTML = votes.map(vote => {
                const address = vote.walletAddress;
                const shortAddress = address.length > 16 ? 
                    `${address.substring(0, 6)}...${address.substring(address.length - 4)}` : 
                    address;
                
                return `
                    <div class="voter-item" title="Full address: ${address}">
                        <span class="voter-address">${shortAddress}</span>
                        <span class="voter-vote ${vote.color}">${vote.color.toUpperCase()}</span>
                    </div>
                `;
            }).join('');
        }

        // Enhanced winner modal
        function showWinner(winnerAddress, prizeAmount, winningColor) {
            const modal = document.getElementById('winnerModal');
            const addressElement = document.getElementById('winnerAddress');
            const prizeElement = document.getElementById('prizeAmount');
            
            addressElement.textContent = winnerAddress ? 
                `${winnerAddress.substring(0, 12)}...${winnerAddress.substring(-8)}` : 
                'No Winner This Round';
            
            prizeElement.textContent = prizeAmount ? `${prizeAmount} SOL` : '0 SOL';
            
            modal.style.display = 'block';
            
            // Create winner explosion
            createWinnerExplosion();
            
            // Play winner sound
            playSound('win');
            
            // Auto close after 12 seconds
            setTimeout(() => {
                closeWinnerModal();
            }, 12000);
        }

        // Show pool announcement
        function showPoolAnnouncement(winningColor, eligibleCount) {
            // Prevent multiple pool announcements
            if (poolAnnounced) {
                console.log('‚ö†Ô∏è Pool already announced, ignoring duplicate');
                return;
            }
            
            poolAnnounced = true;
            
            const modal = document.getElementById('poolModal');
            const poolText = document.getElementById('poolText');
            const poolCount = document.getElementById('poolCount');
            
            // Set the winning color
            modal.className = `pool-announcement ${winningColor}`;
            poolText.className = `pool-text ${winningColor}`;
            poolText.textContent = `${winningColor.toUpperCase()} WINS!`;
            poolCount.textContent = `${eligibleCount} voters eligible`;
            
            // Show the modal
            modal.style.display = 'block';
            
            // Play announcement sound
            playSound('win');
            
            console.log(`üèÜ Pool announcement: ${winningColor} wins with ${eligibleCount} eligible voters`);
        }

        // Close pool modal and start spinning
        function closePoolModal() {
            document.getElementById('poolModal').style.display = 'none';
            
            // Start the spinner instead of the selector
            console.log('üé° Starting spinner after pool announcement');
            startSpinner();
        }

        // Spinner functionality
        function startSpinner() {
            console.log('üé° Starting spinner sequence');
            
            const spinnerContainer = document.getElementById('spinnerContainer');
            const spinnerWheel = document.getElementById('spinnerWheel');
            const spinnerText = document.getElementById('spinnerText');
            const spinnerPointer = document.getElementById('spinnerPointer');
            const spinnerPhaseIndicator = document.getElementById('spinnerPhaseIndicator');
            
            // Show spinner container
            spinnerContainer.style.display = 'flex';
            
            // Phase 1: Red/Black color selection (2 seconds)
            spinnerText.textContent = 'CHOOSING COLOR...';
            spinnerPhaseIndicator.textContent = 'Phase 1: Color Selection';
            spinnerWheel.className = 'spinner-wheel red-black-phase';
            spinnerPointer.className = 'spinner-pointer';
            
            // Play spinning sound
            playSound('spin');
            
            // Start spinning for color selection
            spinnerWheel.classList.add('spinning');
            
            setTimeout(() => {
                // Phase 2: Transition to grey (1 second)
                console.log('üé° Transitioning to grey phase');
                spinnerText.textContent = 'DETERMINING WINNER...';
                spinnerPhaseIndicator.textContent = 'Phase 2: Winner Selection';
                spinnerWheel.className = 'spinner-wheel grey-phase';
                spinnerPointer.className = 'spinner-pointer grey';
                spinnerText.className = 'spinner-text grey';
                
                // Continue spinning in grey phase
                spinnerWheel.style.animation = 'none';
                setTimeout(() => {
                    spinnerWheel.classList.add('spinning');
                }, 50);
                
                // Play different sound for grey phase
                playSound('spinStop');
                
            }, 2000);
            
            setTimeout(() => {
                // Phase 3: Show winner (after total 5 seconds)
                console.log('üé° Showing winner');
                showSpinnerWinner();
            }, 5000);
        }

        function showSpinnerWinner() {
            const spinnerWheel = document.getElementById('spinnerWheel');
            const spinnerText = document.getElementById('spinnerText');
            const spinnerPhaseIndicator = document.getElementById('spinnerPhaseIndicator');
            
            // Stop spinning
            spinnerWheel.classList.remove('spinning');
            spinnerWheel.style.transform = 'rotate(0deg)';
            
            // Get winning color from game state
            const winningColor = gameState?.roundData?.winningColor;
            
            if (winningColor) {
                // Show winner based on winning color
                spinnerText.className = 'spinner-winner';
                spinnerText.textContent = `${winningColor.toUpperCase()} WINS!`;
                spinnerPhaseIndicator.textContent = `Winner: ${winningColor.toUpperCase()}`;
                
                // Change wheel color to match winner
                if (winningColor === 'red') {
                    spinnerWheel.className = 'spinner-wheel red-black-phase';
                    spinnerWheel.style.background = 'conic-gradient(#ff0000 0deg, #ff0000 360deg)';
                } else {
                    spinnerWheel.className = 'spinner-wheel red-black-phase';
                    spinnerWheel.style.background = 'conic-gradient(#000000 0deg, #000000 360deg)';
                }
                
                // Play winner sound
                playSound('win');
                
                // Create winner particles
                createSpinnerWinnerParticles();
                
                console.log('üéâ Spinner winner displayed:', winningColor);
                
                // Close spinner and show winner announcement after 3 seconds
                setTimeout(() => {
                    closeSpinner();
                    showWinnerFromSpinner();
                }, 3000);
            } else {
                console.log('‚ö†Ô∏è No winning color available');
                spinnerText.textContent = 'NO WINNER';
                spinnerPhaseIndicator.textContent = 'No winner this round';
                
                setTimeout(() => {
                    closeSpinner();
                }, 2000);
            }
        }

        function showWinnerFromSpinner() {
            // Get winner from game state
            const winnerAddress = gameState?.roundData?.winner;
            const prizeAmount = gameState?.roundData?.prizeAmount;
            const winningColor = gameState?.roundData?.winningColor;
            
            if (winnerAddress) {
                showWinner(winnerAddress, prizeAmount, winningColor);
            } else {
                // Fallback: show generic winner message if no winner from server
                console.log('‚ö†Ô∏è No server winner available');
                showWinner('No Winner This Round', 0, winningColor);
            }
        }

        function closeSpinner() {
            const spinnerContainer = document.getElementById('spinnerContainer');
            spinnerContainer.style.display = 'none';
            
            // Reset spinner state
            const spinnerWheel = document.getElementById('spinnerWheel');
            const spinnerText = document.getElementById('spinnerText');
            const spinnerPointer = document.getElementById('spinnerPointer');
            const spinnerPhaseIndicator = document.getElementById('spinnerPhaseIndicator');
            
            spinnerWheel.classList.remove('spinning');
            spinnerWheel.style.animation = 'none';
            spinnerWheel.style.transform = 'rotate(0deg)';
            spinnerWheel.style.background = '';
            spinnerWheel.className = 'spinner-wheel red-black-phase';
            spinnerText.className = 'spinner-text';
            spinnerText.textContent = 'CHOOSING COLOR...';
            spinnerPointer.className = 'spinner-pointer';
            spinnerPhaseIndicator.textContent = 'Phase 1: Color Selection';
            
            console.log('üé° Spinner closed and reset');
        }

        function createSpinnerWinnerParticles() {
            const spinnerWheel = document.getElementById('spinnerWheel');
            const rect = spinnerWheel.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            for (let i = 0; i < 40; i++) {
                setTimeout(() => {
                    createParticle(
                        centerX + (Math.random() - 0.5) * 200,
                        centerY + (Math.random() - 0.5) * 200,
                        '#ff0000',
                        Math.random() * 8 + 4,
                        2000
                    );
                }, i * 50);
            }
        }

        // Close winner modal
        function closeWinnerModal() {
            document.getElementById('winnerModal').style.display = 'none';
            hasVoted = false; // Reset for next round
            enableVoting();
        }



        // Copy winner address to clipboard
        async function copyWinnerAddress() {
            const copyBtn = document.getElementById('copyWinnerBtn');
            const address = copyBtn.getAttribute('data-address');
            
            if (!address) {
                console.log('‚ùå No winner address to copy');
                return;
            }
            
            try {
                await navigator.clipboard.writeText(address);
                
                // Visual feedback
                const originalText = copyBtn.textContent;
                copyBtn.textContent = '‚úÖ';
                copyBtn.style.background = 'linear-gradient(135deg, #00ff00, #00cc00)';
                copyBtn.style.boxShadow = '0 0 20px #00ff00';
                
                // Create success particles
                createCopySuccessParticles(copyBtn);
                
                // Play success sound
                playSound('vote');
                
                // Reset button after 2 seconds
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.style.background = 'linear-gradient(135deg, #ff0000, #cc0000)';
                    copyBtn.style.boxShadow = '0 0 15px rgba(255,0,0,0.3), inset 0 0 15px rgba(255,0,0,0.1)';
                }, 2000);
                
                console.log('üìã Winner address copied to clipboard:', address);
            } catch (error) {
                console.error('‚ùå Failed to copy address:', error);
                
                // Fallback: show address in alert
                alert(`Winner Address:\n${address}\n\n(Address copied to your clipboard if supported)`);
            }
        }
        
        // Create success particles for copy action
        function createCopySuccessParticles(button) {
            const rect = button.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    createParticle(
                        centerX + (Math.random() - 0.5) * 40,
                        centerY + (Math.random() - 0.5) * 40,
                        '#00ff00',
                        Math.random() * 4 + 2,
                        1000
                    );
                }, i * 100);
            }
        }

        // Particle effects system
        function createParticle(x, y, color, size = 4, duration = 1000) {
            const particle = document.createElement('div');
            particle.style.position = 'fixed';
            particle.style.left = x + 'px';
            particle.style.top = y + 'px';
            particle.style.width = size + 'px';
            particle.style.height = size + 'px';
            particle.style.background = color;
            particle.style.borderRadius = '50%';
            particle.style.pointerEvents = 'none';
            particle.style.zIndex = '9999';
            particle.style.boxShadow = `0 0 ${size * 2}px ${color}`;
            
            document.body.appendChild(particle);
            
            const animation = particle.animate([
                { transform: 'translate(0, 0) scale(1)', opacity: 1 },
                { transform: `translate(${(Math.random() - 0.5) * 200}px, ${-100 - Math.random() * 100}px) scale(0)`, opacity: 0 }
            ], {
                duration: duration,
                easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
            });
            
            animation.onfinish = () => particle.remove();
        }

        function createVoteExplosion(element, color) {
            const rect = element.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const particleColor = color === 'red' ? '#ff0000' : '#000000';
            
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    createParticle(
                        centerX + (Math.random() - 0.5) * rect.width,
                        centerY + (Math.random() - 0.5) * rect.height,
                        particleColor,
                        Math.random() * 6 + 2,
                        1500
                    );
                }, i * 50);
            }
        }

        function createVoteParticles(element) {
            const rect = element.getBoundingClientRect();
            for (let i = 0; i < 8; i++) {
                createParticle(
                    rect.left + Math.random() * rect.width,
                    rect.top + Math.random() * rect.height,
                    '#ff0000',
                    3,
                    800
                );
            }
        }

        function createVerificationParticles() {
            const button = document.querySelector('.verify-btn');
            const rect = button.getBoundingClientRect();
            
            for (let i = 0; i < 15; i++) {
                setTimeout(() => {
                    createParticle(
                        rect.left + Math.random() * rect.width,
                        rect.top + Math.random() * rect.height,
                        '#ff0000',
                        4,
                        1200
                    );
                }, i * 100);
            }
        }

        function createConnectionParticles() {
            const status = document.getElementById('connectionStatus');
            const rect = status.getBoundingClientRect();
            
            for (let i = 0; i < 10; i++) {
                createParticle(
                    rect.left + rect.width / 2,
                    rect.top + rect.height / 2,
                    '#ff0000',
                    3,
                    1000
                );
            }
        }

        function createUpdateParticles() {
            // Create subtle particles on game updates
            for (let i = 0; i < 3; i++) {
                createParticle(
                    Math.random() * window.innerWidth,
                    Math.random() * 100,
                    '#ff0000',
                    2,
                    2000
                );
            }
        }

        function createUrgencyParticles() {
            const timer = document.getElementById('timer');
            const rect = timer.getBoundingClientRect();
            
            for (let i = 0; i < 5; i++) {
                createParticle(
                    rect.left + Math.random() * rect.width,
                    rect.top + Math.random() * rect.height,
                    '#ff0000',
                    5,
                    600
                );
            }
        }


        function createWinnerExplosion() {
            const modal = document.getElementById('winnerModal');
            const rect = modal.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    const angle = (i / 50) * 2 * Math.PI;
                    const radius = Math.random() * 200 + 50;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    createParticle(x, y, '#ff0000', Math.random() * 8 + 4, 2000);
                }, i * 50);
            }
        }

        // Enhanced sound system
        function playSound(type) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                switch (type) {
                    case 'vote':
                        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        break;
                    case 'spin':
                        oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 2);
                        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 2);
                        break;
                    case 'spinStop':
                        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.5);
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                        break;
                    case 'win':
                        // Victory fanfare
                        [600, 800, 1000, 1200].forEach((freq, i) => {
                            setTimeout(() => {
                                const osc = audioContext.createOscillator();
                                const gain = audioContext.createGain();
                                osc.connect(gain);
                                gain.connect(audioContext.destination);
                                osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                                gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                                osc.start(audioContext.currentTime);
                                osc.stop(audioContext.currentTime + 0.3);
                            }, i * 150);
                        });
                        return; // Don't execute default logic
                }
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 2);
            } catch (error) {
                // Sound not supported, fail silently
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'r' || e.key === 'R') {
                if (!document.getElementById('redButton').disabled) {
                    vote('red');
                }
            } else if (e.key === 'b' || e.key === 'B') {
                if (!document.getElementById('blackButton').disabled) {
                    vote('black');
                }
            } else if (e.key === 'Enter') {
                if (document.activeElement === document.getElementById('walletInput')) {
                    verifyWallet();
                }
            } else if (e.key === 's' || e.key === 'S') {
                // Manual spin trigger for testing
                console.log('üé° Manual spin triggered via keyboard');
                testSpin();
            } else if (e.key === 'w' || e.key === 'W') {
                // Manual spinner trigger for testing
                console.log('üé° Manual spinner triggered via keyboard');
                testSpinner();
            } else if (e.key === 'i' || e.key === 'I') {
                // Manual initialization trigger for testing
                console.log('üîß Manual initialization triggered');
                isInitialized = true;
                console.log('‚úÖ App manually initialized - spinning now allowed');
            }
        });

        // Test spin function for debugging
        function testSpin() {
            console.log('üß™ Testing pool announcement and spin...');
            
            // Show pool announcement first
            showPoolAnnouncement('red', 3);
        }

        // Test spinner function for debugging
        function testSpinner() {
            console.log('üß™ Testing spinner directly...');
            
            // Set up mock game state for testing
            if (!gameState) {
                gameState = {
                    roundData: {
                        winningColor: 'red',
                        winner: 'TestWinner123456789',
                        prizeAmount: 1.5,
                        recentVotes: [
                            { walletAddress: 'TestWinner123456789', color: 'red' },
                            { walletAddress: 'TestVoter234567890', color: 'red' },
                            { walletAddress: 'TestVoter345678901', color: 'black' }
                        ]
                    }
                };
            }
            
            // Start spinner directly
            startSpinner();
        }

        // Mouse trail effect
        let mouseTrail = [];
        document.addEventListener('mousemove', (e) => {
            mouseTrail.push({ x: e.clientX, y: e.clientY, time: Date.now() });
            
            // Limit trail length
            if (mouseTrail.length > 10) {
                mouseTrail.shift();
            }
            
            // Create trail particles occasionally
            if (Math.random() < 0.1) {
                createParticle(e.clientX, e.clientY, '#ff0000', 2, 500);
            }
        });

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üé∞ Initializing Red or Black Casino...');
            
            // Add loading animation
            document.body.classList.add('loading');
            
            setTimeout(() => {
                document.body.classList.remove('loading');
                initializeConnection();
                
                // Set initialization flag after a delay to prevent auto-spinning
                setTimeout(() => {
                    isInitialized = true;
                    console.log('‚úÖ App initialization complete - spinning now allowed');
                }, 2000);
                
                // Auto-refresh intervals - reduced frequency to prevent timer conflicts
                setInterval(fetchParticipants, 5000);
                setInterval(fetchGameStatus, 5000);
                
                console.log('üî• Red or Black Casino is LIVE!');
            }, 1000);
        });

        // Performance monitoring
        let lastUpdateTime = Date.now();
        function checkPerformance() {
            const now = Date.now();
            const deltaTime = now - lastUpdateTime;
            
            if (deltaTime > 8000) {
                console.warn('‚ö†Ô∏è Performance warning: No updates received recently');
                updateConnectionStatus(false);
            }
            
            lastUpdateTime = now;
        }

        setInterval(checkPerformance, 10000);

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (socket) {
                socket.disconnect();
            }
            if (timerInterval) {
                clearInterval(timerInterval);
            }
        });

        // Handle visibility changes
        let wasHidden = false;
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('üî¥ Page hidden - reducing updates');
                wasHidden = true;
                lastVisibilityChange = Date.now();
                // Reset spinning state when page is hidden to prevent issues on return
                isSpinning = false;
                poolAnnounced = false;
            } else {
                console.log('üî¥ Page visible - resuming full updates');
                lastVisibilityChange = Date.now();
                
                if (wasHidden) {
                    console.log('üîÑ Page was hidden, resetting states and fetching fresh data');
                    // Reset all states when returning from hidden state
                    isSpinning = false;
                    poolAnnounced = false;
                    
                    // Immediately sync timer when page becomes visible
                    console.log('üïê Syncing timer with server after tab switch');
                    fetchGameStatus();
                    
                    // Close any open modals/overlays
                    const spinnerContainer = document.getElementById('spinnerContainer');
                    const winnerModal = document.getElementById('winnerModal');
                    const poolModal = document.getElementById('poolModal');
                    
                    if (spinnerContainer) spinnerContainer.style.display = 'none';
                    if (winnerModal) winnerModal.style.display = 'none';
                    if (poolModal) poolModal.style.display = 'none';
                    
                    wasHidden = false;
                }
                
                // Only fetch data if we're properly initialized and wait a bit to prevent immediate triggering
                if (isInitialized) {
                    setTimeout(() => {
                        if (!document.hidden) { // Double-check we're still visible
                fetchGameStatus();
                fetchParticipants();
                        }
                    }, 1000); // 1 second delay
                }
            }
        });
    </script>
</body>
</html>
